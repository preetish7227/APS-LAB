# -*- coding: utf-8 -*-
"""Lab_1_AlgorithmsBasics.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ywKB7u1fZNWvbO-j8rf-wvGKJsPLiAFQ

# 1. Algorithm's Basics

- **Created by Dr. Ajay**
- **Created on Dec 18, 2021**
- **Updated on May 18, 2025**

## Algorithms
In mathematics and computer science, an algorithm is a finite sequence of well-defined, computer-implementable instructions, typically to solve a class of problems or to perform a computation <a href="#link_one">[1]</a>.
"""

# Load the Python libraries
import math
import random
import timeit
import numpy as np
from scipy import stats as sci
import statistics as stats
from itertools import cycle

# Load plotting libraries
import matplotlib.pyplot as plt

"""## 1.1. Greatest Common Divisor (GCD)

The greatest common divisor (GCD) of two or more integers, which are not all zero, is the largest positive integer that divides each of the integers. For two integers $ x, y $, the greatest common divisor of $x$ and $y$ is denoted $ gcd(x,y) $ <a href="#link_two">[2]</a>. For example, the GCD of 8 and 12 is 4, that is, $ gcd(8,12)=4 $.
"""

# Example values
m = 12000000
n = 76000000

"""### 1.1.1. Simple approach"""

# Write a Function named as gcd_simple() that returns the GCD of two values

def gcd_simple(a, b):
    if a == 0:
      return b
    while b != 0:
        a, b = b, a % b
    return a

#Compute the elapsed time in ms for computing gdc with the help of above function
import time
start=time.time()
print(gcd_simple(48, 18))
end=time.time()
print(end-start)



"""### 1.1.2. Enhanced approach"""

# Function that returns the GCD of two values (euclidean algorithm)
def gcd_euclidean(m, n):
    m = min(m, n)
    n = max(m, n)

    while m > 0:
        t = m
        m = n % m
        n = t

    return n

# Compute the elapsed time in ms for computing gdc with the help of gcd_euclidean()function
import time
start=time.time()
m = 12000000
n = 76000000
gcd_euclidean(m, n)
end = time.time()
print(end-start, "ms")

"""## 1.2. Fibonacci Serie

In mathematics, the Fibonacci numbers, commonly denoted $ F_n $, form a sequence, called the Fibonacci sequence, such that each number is the sum of the two preceding ones, starting from 0 and 1. That is <a href="#link_three">[3]</a>,

$ \quad F_{0}=0,\quad F_{1}=1, $  
and  
$ \quad F_{n}=F_{n-1}+F_{n-2} $  
for n > 1.

The beginning of the sequence is thus:  
$ \quad 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, ... $
"""

# Example value
n = 35

"""### 1.2.1. Recursive algorithm"""

# Function that returns the n-fibonacci value (recursive algorithm)
def fibo_rec(n):
    if n < 2:
        return n
    else:
        return fibo_rec(n - 1) + fibo_rec(n - 2)

#compute the time in ms for above cell.
import time
start = time.time()
n=35
print(fibo_rec(n))
end = time.time()
print("elapsed time",end-start,"ms")

"""### 1.2.2. Iterative algorithm"""

# Function that returns the n-fibonacci value (iterative algorithm)
def fibo_iter(n):
    i, j = 1, 0

    for k in range(n):
        j = i + j
        i = j - i

    return j

#compute time in ms for iteratve alforithm.
import time
def fibo_iter(n):
    i, j = 1, 0

    for k in range(n):
        j = i + j
        i = j - i

    return j
start = time.time()
n=35
print(fibo_iter(n))
end = time.time()
print("elapsed time",end-start,"ms")

"""### 1.2.3. Approximation approach
With the De Moivre's formula:

$$ f_{n} = {\frac{1}{\sqrt{5}}}{[\phi^n -(-\phi)^{-n}]} \tag{1}, $$
$$ \phi = (1 + \sqrt{5})\,/\,2 $$
"""

# Function that returns the n-fibonacci value (De Moivre equation)
def fibo_de_moivre(n):
    golden_ratio = (1 + 5**(1/2)) / 2
    f = (golden_ratio**n - (-golden_ratio)**(-n)) / 5**(1/2)
    return int(f)

#compute time in ms of above cell (de moivre equation)
import time
def fibo_de_moivre(n):
    golden_ratio = (1 + 5**(1/2)) / 2
    f = (golden_ratio**n - (-golden_ratio)**(-n)) / 5**(1/2)
    return int(f)
start = time.time()
n=35
print(fibo_de_moivre(n))
end = time.time()
print("elapsed time",end-start,"ms")

"""## 1.3. Integer Factorization

In number theory, integer factorization is the decomposition of a composite number into a product of smaller integers. If these factors are further restricted to prime numbers, the process is called prime factorization <a href="#link_four">[4]</a>.
"""

# Example values
a, b = 104723, 104729
n = a * b
n

# Function that returns the factorization of an integer (ascending approach)
def fact_int(n):
    nn = n**(1/2)
    m = 2

    while m < nn:
        if n % m == 0:
            return (m, n // m)
        m += 1

    return (1, n)

# compute time for above cell
import time
def fact_int(n):
    nn = n**(1/2)
    m = 2

    while m < nn:
        if n % m == 0:
            return (m, n // m)
        m += 1

    return (1, n)
start = time.time()
a, b = 104723, 104729
n = a * b
n
print(fact_int(n))
end = time.time()
print("elapsed time",end-start,"ms")

# Function that returns the factorization of an integer (descending approach)
def fact_int_2(n):
    nn = n**(1/2)
    m = int(nn)

    while m > 1:
        if n % m == 0:
            return (m, n // m)
        m -= 1

    return (1, n)

#compute time for above cell
import time
def fact_int_2(n):
    nn = n**(1/2)
    m = int(nn)

    while m > 1:
        if n % m == 0:
            return (m, n // m)
        m -= 1

    return (1, n)
start = time.time()
a, b = 104723, 104729
n = a * b
n
print(fact_int(n))
end = time.time()
print("elapsed time",end-start,"ms")

"""## 1.4. Tower of Hanoi

The Tower of Hanoi is a mathematical game or puzzle. It consists of three rods and a number of disks of different sizes, which can slide onto any rod. The puzzle starts with the disks in a neat stack in ascending order of size on one rod, the smallest at the top, thus making a conical shape <a href="#link_five">[5]</a>.
"""

# Disk number between 2 and 64 (not recommended)
n_disks = 5

"""### 1.4.1. The recursive and classic algorithm"""

# Move n disk from source to destination
def hanoi_rec(n, source, aux, target):
    if n > 0:
        hanoi_rec(n - 1, source, target, aux)
        print('Move disk', n, 'from:', source, 'to:', target)
        hanoi_rec(n - 1, aux, source, target)

import timeit
def hanoi_rec(n, source, aux, target):
    if n > 0:
        hanoi_rec(n - 1, source, target, aux)
        print('Move disk', n, 'from:', source, 'to:', target)
        hanoi_rec(n - 1, aux, source, target)
start_time = timeit.default_timer()
n_disks = 5
print('>> number of movements:', (2**n_disks - 1))
hanoi_rec(n_disks, 'T1', 'T2', 'T3')
print('>> elapsed time', (timeit.default_timer() - start_time) * 1000, 'ms')

"""### 1.4.2. Iterative algorithm"""

# Move n disk from source to destination
def hanoi_iter(n, source, aux, target):
    n_movements = 2**n_disks - 1
    print('>> number of movements:', n_movements)

    tw_src = []
    for i in range(n_disks, 0, -1):
        tw_src.append(i)

    labels = [source, aux, target]
    towers = [tw_src, [], []]
    indexes = cycle([0, 1, 2] if n % 2 == 0 else [0, 2, 1])
    temp = next(indexes)
    disk = 0

    for i in range(1, n_movements + 1):
        if i % 2 == 1:
            disk = 1
            s, t = temp, next(indexes)
            temp = t
            towers[t].append(towers[s].pop())
            print('Move disk', disk, 'from:', labels[s], 'to:', labels[t])
        else:
            i_t2, i_t3 = [i for i in range(3) if i != temp]
            v_t2 = towers[i_t2][len(towers[i_t2]) - 1] if len(towers[i_t2]) else math.inf
            v_t3 = towers[i_t3][len(towers[i_t3]) - 1] if len(towers[i_t3]) else math.inf

            if v_t2 < v_t3:
                s, t = i_t2, i_t3
            else:
                s, t = i_t3, i_t2

            disk = towers[s].pop()
            towers[t].append(disk)
            print('Move disk', disk, 'from:', labels[s], 'to:', labels[t])

import timeit
import math
from itertools import cycle

def hanoi_iter(n, source, aux, target):
    n_movements = 2**n - 1
    print('>> number of movements:', n_movements)

    # Initialize towers
    tw_src = list(range(n, 0, -1))  # disks stacked largest (n) at bottom to smallest (1) at top
    labels = [source, aux, target]
    towers = [tw_src, [], []]

    # Cycle order depends on parity of n
    indexes = cycle([0, 1, 2] if n % 2 == 0 else [0, 2, 1])
    temp = next(indexes)

    for i in range(1, n_movements + 1):
        if i % 2 == 1:
            # Move the smallest disk
            s, t = temp, next(indexes)
            temp = t
            disk = towers[s].pop()
            towers[t].append(disk)
            print(f'Move disk {disk} from {labels[s]} to {labels[t]}')
        else:
            # Make the only other legal move
            i_t2, i_t3 = [j for j in range(3) if j != temp]
            v_t2 = towers[i_t2][-1] if towers[i_t2] else math.inf
            v_t3 = towers[i_t3][-1] if towers[i_t3] else math.inf

            if v_t2 < v_t3:
                s, t = i_t2, i_t3
            else:
                s, t = i_t3, i_t2

            disk = towers[s].pop()
            towers[t].append(disk)
            print(f'Move disk {disk} from {labels[s]} to {labels[t]}')

# Run example
start_time = timeit.default_timer()
hanoi_iter(5, 'T1', 'T2', 'T3')
print('>> elapsed time', (timeit.default_timer() - start_time) * 1000, 'ms')

"""## 1.5. Sorting Algorithm

**Bubble sort**, sometimes referred to as sinking sort, is a simple sorting algorithm that repeatedly steps through the list, compares adjacent elements and swaps them if they are in the wrong order. The pass through the list is repeated until the list is sorted. The algorithm, which is a comparison sort, is named for the way smaller or larger elements "bubble" to the top of the list <a href="#link_six">[6]</a>.
"""

def bubble_sort(arr):
    n = len(arr)
    for i in range(n - 1):
        for j in range(0, n - i - 1):
            if arr[j] > arr[j + 1]:
                arr[j], arr[j + 1] = arr[j + 1], arr[j]
    return arr

"""With time complexity of $ \Theta(n^2) $ and space complexity of $ \Theta(n) $."""

# Example values
import random
n = 100
raw_data = []
for i in range(n):
    raw_data.append(int(random.random() * n))

# Sorting data
sorted_data = bubble_sort(raw_data.copy())

# Plotting
import matplotlib.pyplot as plt

fig = plt.figure(figsize = (16, 8))
fig.subplots_adjust(hspace = 0.15, wspace = 0.15)

# Plotting results before sorting
plt.subplot(1, 2, 1)
plt.plot(raw_data, linewidth=0, marker="o", markersize=3, color="#3366cc")
plt.title("Data Before Sorting", fontsize = 14)
plt.ylabel('Value')
plt.xlabel('Index')

# Plotting results after sorting
plt.subplot(1, 2, 2)
plt.plot(sorted_data, linewidth=0, marker="o", markersize=3, color="#109618")
plt.title("Data After Sorting", fontsize = 14)
plt.ylabel('Value')
plt.xlabel('Index')
plt.show()

"""## References

<a name='link_one' href='https://en.wikipedia.org/wiki/Algorithm' target='_blank' >[1]</a> Wikipedia - Algorithm.  
<a name='link_two' href='https://en.wikipedia.org/wiki/Greatest_common_divisor' target='_blank' >[2]</a> Wikipedia - Greatest common divisor.  
<a name='link_three' href='https://en.wikipedia.org/wiki/Tower_of_Hanoi' target='_blank' >[3]</a> Wikipedia - Tower of Hanoi.  
<a name='link_four' href='https://en.wikipedia.org/wiki/Integer_factorization' target='_blank' >[4]</a> Wikipedia - Integer factorization.  
<a name='link_five' href='https://en.wikipedia.org/wiki/Bubble_sort' target='_blank' >[5]</a> Wikipedia - Bubble sort.
"""